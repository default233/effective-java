# 一、用静态工厂方法代替构造方法

提供公有的**静态工厂方法**，返回类的实例。

例如：

```java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

## 优势

### 1. 各有名称。

具有适当名称的静态工厂会更容易使用和阅读，通过名称突出不同方法之间的区别。如

```java
BigInteger.probablePrime()
```

### 2. 可以不必每次调用时都创建新的对象

可以使用预先创建好的实例，如单例模式、享元模式，上面的 `Boolean.valueOf` 就使用了这个技术

### 3. 可以返回子类型的对象

同时还可以通过API返回对象，同时不会使对象的类变成公有的。例如 `java.util.Collections` 中导出的对象，如 synchronizedList()  返回了类的内部定义的非公有类的对象

```java
static class SynchronizedList<E>
        extends SynchronizedCollection<E>
        implements List<E>
    
static class SynchronizedRandomAccessList<E>
        extends SynchronizedList<E>
        implements RandomAccess
    
public static <T> List<T> synchronizedList(List<T> list) {
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList<>(list) :
            new SynchronizedList<>(list));
}
```

### 4. 返回的对象的类可以随着每次调用的传参而发生变化

只有是已声明的类型的子类型，都可以返回。例如 `EnumSet` 没有公有的构造方法，只有静态工厂方法，具体返回取决于底层枚举类型的大小，若元素有64个或更少，则返回 `RegularEnumSet` 实例，否则返回 `JumboEnumSet`。

```
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType)

public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType)t;

public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s)

public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c)

public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s)
```

### 5. 方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在

一个典型的例子是 JDBC API，被称为 **服务提供者框架（Service Provider Framework）** 。

该框架分为四个组件

- 服务接口（Service Interface）：Connection
- 提供者注册API（Provider Registration API）：DriverManager.registerDriver
- 提供者接口（Service Provider Interface）：Driver
- 服务访问API（Service Access API）：DriverManager.getConnection

## 劣势

### 1. 类如果不含有公有的或受保护的构造方法，就不能被子类化

### 2. 程序员很难发现并使用。

在API文档中，没有像构造方法一样明确标识出来

## 常用的静态方法名称

- from —— 类型转换方法
- of —— 聚合方法
- valueOf 
- instance 或者 getInstance
- create 或者 newInstance
- get*Type*

- new*Type*
- *type*

# 二、遇到多个构造器参数时，要考虑使用构建器

当遇到成员变量较多的类时，使用构造方法初始化对象会使得代码的可读性以及规范性变差。比如想知道某个参数的含义时必须要查看构造方法的定义源码。而且如果不消息颠倒了参数的顺序，编译器可能也不会报错。

可以使用 JavaBean 的模式，使用无参的构造方法创建对象，然后调用 setter 方法为对象的属性赋值

使用 setter 的缺点是：

- 初始化过程被分到了几个方法的调用过程，在构造过程中，JavaBean 可能处于不一致的状态
- 使用把类做成不可变的可能性不存在 

或者使用 建造者（Builder）模式 。

它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个 builder 对象。然后客户端在 builder 对象上，调用类似 setter 的方法，来设置每个相关的可选参数。最后，客户端调用无参的 build 方法来生成通常是不可变的对象。这个 builder 通常是它构建的类的静态成员类。

```java
/**
 * 普通的构造方法
 */
public class Person {
    private Long id;
    private String name;
    private Integer age;
    private Integer height;

    public Person() {
    }

    public Person(Long id, String name, Integer age, Integer height) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.height = height;
    }
}
```

```java
/**
 * setter
 */
public class Person {
    private Long id;
    private String name;
    private Integer age;
    private Integer height;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getHeight() {
        return height;
    }

    public void setHeight(Integer height) {
        this.height = height;
    }

    public Person() {
    }

}
```

```java
/**
 * 建造者模式
 */
public class Person {
    private Long id;
    private String name;
    private Integer age;
    private Integer height;
    
    public static class Builder {
        // 必须参数
        private Long id;
        // 可选参数
        private String name;
        private Integer age;
        private Integer height;
        
        public Builder(Long id) {
            this.id = id;
        }
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder age(Integer age) {
            this.age = age;
            return this;
        }
        
        public Builder height(Integer height) {
            this.height = height;
            return this;
        }
        
        public Person build() {
            return new Person(this);
        }
    }

    public Person(Builder builder) {
        id = builder.id;
        name = builder.name;
        age = builder.age;
        height = builder.height;
    }

    public Person() {
    }
}
```

注意：

- builder 的设值方法返回的是 builder 本身，以便把调用链接起来，形成流式的 API
- Builder 模式模拟了具名的可选参数
- Builder 模式也适用于类层次结构
- 如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder 模式就是一种不错的选择

# 三、使用私有构造器或者枚举类型强化 Singleton 属性

Singleton 单例，表示仅仅被实例化一次的类。

将构造器私有化是实现 Singleton 的常见方法

如

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis () {}
    
    public void leaveTheBuilding() {
        
    }
}

```

此时，静态 final 域 Elvis.INSTANCE 是公有的，通过私有化构造器保证了全局唯一性

或者

```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis () {}

    public static Elvis getInstance() {
        return INSTANCE;
    }
    
    public void leaveTheBuilding() {

    }
}
```

通过使用公有静态工厂方法获取 Elvis 实例

## 优势

### 1. 提供了灵活性

使用工厂方法很容易进行修改，例如，改成每个调用该方法的线程返回一个唯一的实例

### 2. 可以编写泛型 Singleton 工厂

### 3. 可以通过方法引用作为 supplier

## 注意

在声明中加上 implenments Serializable ，无法保证序列化后对象仍是单例的。因为在反序列化时，会创建一个新的实例。

因此，需要将实例域声明为 **transient**，然后提供一个 readResolve 方法

```java
private Object readResolve() {
    return INSTANCE;
}
```

## 使用枚举类型实现单例

```java
public enum Elvis { 
	INSTANCE;
    public void leaveTheBuilding() { }

}
```

该方式更加简洁、并无偿提供了序列化机制，使用单元素的枚举类型经常成为实现 Singleton 的最佳方法

# 四、通过私有构造器强化不可实例化的能力

一些类只需要包含静态方法和静态域，例如 `java.lang.Math`。这些工具类不希望被实例化，因为实例化对其没有任何意义。但如果不指定显式构造器，编译器会自动提供一个公有无参构造器。

不应该通过将类做成抽象类来强制该类不可实例化。

只需要将这个类包含一个私有的构造器，就不能被实例化

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

上述 AssertionError 不是必须的，但是可以避免不小心在类的内部调用了构造全球，因此保证了在任何情况下，该类都不会被实例化。

一旦如此定义，该类就无法被子类化。因为所有的构造器都必须显式或隐式地调用父类构造器。

# 五、优先考虑依赖注入来引入资源

有许多类会依赖一个或多个底层的资源。即这个类可能会依赖其他的类的实例。

最好的采取做法是，当创建一个新的实例时，就将该实例所依赖的资源传入到构造器中。这就是依赖注入的一种形式。

```java
public class SpellChecker {
    private final Lexicon dictionary;
    
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
    
}
```

依赖注入的对象资源具有不可变性，因此多个客户端可以共享依赖对象。

也可以将资源工厂传给构造器。工厂是可以被重复调用来创建类型实例的一个对象。在 Java 8 中新增的接口 Supplier\<T> 可以用于表示工厂。例如

```java
Mosaic create(Supplier<? extends Tile> tileFactory) {}
```

依赖注入会导致大型项目结构凌乱，可以通过使用依赖注入框架解决，如 Dagger、Guice、Spring

# 六、避免创建不必要的对象

如果对象是不可变的，那么它就始终可以被重用。

反面例子

```java
String s = new String("bikini");
```

该语句每次被执行时，都会创建一个新的 String 实例，但是这些创建对象的动作是不必要的。传递给 String 构造器的参数本身就是一个 String 实例，功能方面等同于构造器创建的所有对象。应该改进为

```java
String s = "bikini";
```

对于同时提供了静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法而不是构造器方法，以避免创建不必要的对象。

也可以重用那些已知不会被修改的可变对象。

有些对象创建的成本比其他对象高得多。如果重复需要这样的类，建议将其缓存下来重用。

例如，假设编写方法用它确定一个字符串是否为一个有效的罗马数字，简单实现为：

```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(>=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

这个实现的问题在于它依赖 String.matches 方法。虽然 String.matches 方法最易于查看一个字符串是否于正则表达式相匹配，但是并不适合在注重性能的情形中重复使用。

问题在于，它在内部为正则表达式创建了一个 Pattern 实例，却只用到了一次，之后就进行垃圾回收了。创建 Pattern 实例的成本很高，因为需要将正则表达式编译成一个有限状态机。

```java
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}
public static boolean matches(String regex, CharSequence input) {
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(input);
    return m.matches();
}
public static Pattern compile(String regex) {
    return new Pattern(regex, 0);
}
```

为了提升性能，应该显示得将正则表达式编译为一个不可变的 Pattern 实例，让它成为类初始化的一部分，并将其缓存，每当调用方法时，用同一个实例

```java
public class RomanNumerals {
    private static final Pattern ROMAN = 
        Pattern.compile("^(>=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

同时可以使用延迟初始化使得 ROMAN 域只有在真正使用 isRomanNumeral() 方法时才被创建。

考虑适配器情形。由于适配器除了后备对象之外，没有其他的状态信息，所以针对某个给定对象的特定适配器而言，它不需要创建多个适配器实例

例如 Map 接口的 keySet 方法返回该 Map 对象的 Set 视图。因为 map 对象是可变的，好像每次调用 keySet 方法都应该新创建一个 Set 实例。但是所有返回对象在功能上应该是等同的，当 map 发生变化时，所有的 keySet 都应该发生变化，因此仅需要一个 Set ，创建多个实例是没有必要的

```java
transient Set<K> keySet;
public Set<K> keySet() {
    Set<K> ks = keySet;
    if (ks == null) {
        ks = new KeySet();
        keySet = ks;
    }
    return ks;
}
```

考虑自动装箱。自动装箱使得基本类型和包装类型之间的差别变得模糊起来，但是在语义和性能上有着较为明显的区别。

下列方法计算所有 int 正整数值的总和

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```

这段程序的正确性没有问题，但是比实际情况更慢一些。原有就是 sum 变量被声明为了 Long 而不是 long。这意味着程序构造了大约 $2^{31}$ 个多余的 Long 实例。因此，要优先使用基本类型而不是包装类型。

注意：小对象的创建和回收是非常廉价的，维护对象池来避免创建对象并不总是好的做法，除非对象是非常重量级的。

# 七、消除过期的对象引用

在手工管理内存的语言中（如“C++”），当对象使用之后，需要手动释放其所占有的内存，例如 C++ 中的析构函数。但 Java 具有垃圾回收器，降低了内存管理的难度，但仍会出现内存泄漏的风险。如：

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2*size +1);
        }
    }
}
```

在这段程序中，看似没有问题，但如果让栈中的元素先增多后减少，在 pop() 方法中，由于仅仅对 size 做了减小，而并没有删除对象，所以仍然存在着对无效对象的引用，因而垃圾回收器就不会将其当作垃圾进行回收。对象的过期引用造成了内存泄漏。

因此应该将 pop() 方法更改为

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    
    Object result = elements[--size];
    elements[size] = null;
    return result;
}
```

内存泄漏的另一个常见来源是缓存。放入缓存中的对像一般很容易被遗忘掉，因此即使它不再使用之后，也可能很长一段时间内都会留在缓存中。可以使用 WeakHashMap 解决某些场景下的问题。

WeakHashMap，如果 Map 之外存在对键的引用，则可以正常使用，但当键的外部引用消失时，该项就会被删除。

内存泄漏第三个常见的来源是监听器和其他回调。如果实现了一个 API ，客户端中 API 中注册回调，却没有显示地取消注册，它们就会不断堆积起来。此时也可以使用 WeakHashMap 进行解决。

# 八、避免使用终结方法和清除方法

## 缺点

首先应该清楚的是，终结方法（finalize()）不等同于 C++ 中等析构方法。

这类方法不能保证其会被及时执行，甚至不能保证会被执行，因此，不应该依赖终结方法或者清除方法来更新重要的持久状态。

终结方法内部如果产生了未被捕获的异常，则终结方法也会异常终止，而且，不会打印异常警告。

使用终结方法会产生非常严重的性能损失。主要是因为终结方法阻止了有效的垃圾回收。

终结方法也存在安全问题。可以通过反序列化的对象抛出异常，使得恶意子类的终结方法中构造了一部分的对象上运行，将该对象引用记录到静态域中，防止被垃圾回收器回收。因此对于非 final 类，要编写一个空的 final 的 finalize 方法，以防止收到终结方法的攻击。

## 优点

第一种用途是，当资源的所有者忘记调研其 close 方法时，可以使用终结方法或清除方法来充当 “安全网”，即最后一道防线。

第二种用途与对象的本地对等体有关。本地对等体是非 Java 的本地对象，通过本地方法（native），普通对象可以委托给本地对象。因为本地对象不受垃圾回收器的管控，因此，可以在终结方法或者清除方法中，完成对本地对象资源的管理。

# 九、try-with-resources 优先于 try-finally

根据传统，try-finally 块是确保关闭资源的一个有效方法，但是当多个资源时，就可能造成代码的混乱。而且某个 finally 块中也可能抛出异常，就会使得之前抛出的异常信息被覆盖。

```java
public static void copy(String src, String dst) throws IOException {
    InputStream in = new FileInputStream(src);
    try {
        OutputStream out = new FileOutputStream(dst);
        try {
            byte[] buf = new byte[16];
            int n;
            while ((n = in.read(buf)) >= 0) {
                out.write(buf, 0, n);
            }
        } finally {
            out.close();
        }
    } finally {
        in.close();
    }

}
```

在 Java 7 中引入了 try-with-resources 语句之后，就产生了更为方便规范的方式。使用该语句的资源必须实现 AutoCloseable 接口。

```java
public static void copy2(String src, String dst) throws IOException {
    try(InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[16];
        int n;
        while ((n = in.read(buf)) >= 0) {
            out.write(buf, 0, n);
        }
    }
}
```

这时，如果前面出现异常，后面的异常就会被禁止。
